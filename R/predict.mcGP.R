##' Prediction for mesh-clustered Gaussian process emulator 
##' @title Prediction for mesh-clustered Gaussian process emulator 
##' @param fit a class of \code{mcGP}.
##' @param Y same as \code{Y} for \code{\link[mcGP]{mcGP}}.
##' @param xnew an \code{n.new times d} matrix specifying the test input data. The default is \code{X} in \code{\link[mcGP]{mcGP}}.
##' @param array.fg logical. If \code{TRUE}, the prediction mean and variance for each cluster will be returned.
##' 
##' 
##' @seealso \code{\link[mcGP]{mcGP}} for model fitting.
##' 
##' @export predict.mcGP
##' @export
##' @examples
##' \dontrun{
##'library(mcGP)
##'set.seed(1)
##'
##'##### setting #####
##' # example: Poisson equation simulations 
##' # (data was generated by finite element methods via MATLAB)
##' data(poisson_dat)
##' attach(poisson_dat)
##' 
##' print(dim(X)) # sample size is 5; one input variable
##' print(dim(S)) # 2-dimensional mesh; 401 mesh nodes
##' print(dim(Y)) # sample size is 5; 401 outputs at mesh nodes
##' 
##' # visualize two training examples
##' pde.plot <- function(u, nodes, ...){
##'   out <- as.image(u, x = nodes, nrow=128, ncol=128)
##'   dx <- out$x[2] - out$x[1] 
##'   dy <- out$y[2] - out$y[1] 
##'   out <- image.smooth(out$z, dx=dx, dy=dy, theta=.25) 
##'   image.plot(x = out$x, y = out$y, z = out$z, ...)
##' }
##' 
##' par(mfrow=c(1,2))
##' pde.plot(Y[,1], S, main=paste("x =", X[1,1]))
##' pde.plot(Y[,5], S, main=paste("x =", X[5,1]))
##'
##' # model fitting
##' fit <- mcGP(X,Y,S)
##' print(fit$time.elapsed) # the time elapsed
##' 
##' # model fitting (with parallel computing)
##' fit <- mcGP(X,Y,S, parallel=TRUE)
##' print(fit$time.elapsed) # the time elapsed
##'}
predict.mcGP <- function(fit, Y, xnew=NULL, array.fg=FALSE){
  
  X <- fit$X
  theta <- fit$theta
  tau2 <- fit$tau2
  q_Z <- fit$q_Z
  nu <- fit$nu
  g <- fit$g
  d <- fit$d
  p <- fit$p
  n <- fit$n
  N <- fit$N
  K <- fit$VI.settings$K
  
  if(is.null(xnew)){
    xnew <- X
  }
  
  n.new <- nrow(xnew)
  
  y.pred <- matrix(0, nrow=N, ncol=n.new)
  # if(array.fg) y.pred.array <- y.sig2.array <- array(0, c(N,n.new,K))
  y.sig2 <- matrix(0, nrow=N, ncol=n.new)
  
  tick <- proc.time()
  for(k in 1:K){
    Phi <- matern.kernel(X,theta[k,],nu=nu) + g*diag(1,n)
    Phi.inv <- solve(Phi)
    Phi_Xx <- matern.kernel(X,theta[k,],nu,xnew)
    DD <- t(Phi_Xx)%*%Phi.inv
    if(array.fg) y.pred.array[,,k] <- t(DD%*%t(Y))
    y.pred <- y.pred + t(DD%*%t(Y)) * q_Z[,k]
    
    y.sig2 <- y.sig2 + t(outer(tau2[k]*(1+g-pmin(1, diag(DD%*%Phi_Xx))), q_Z[,k])) +
      t(DD%*%t(Y))^2 * q_Z[,k]
    if(array.fg) y.sig2.array[,,k] <- t(outer(tau2[k]*(1+g-pmin(1, diag(DD%*%Phi_Xx))), rep(1,N)))
    
  }
  tock <- proc.time()
  
  if(array.fg){
    return(list(mean=y.pred, sig2=y.sig2-(y.pred)^2, 
                mean.array=y.pred.array, sig2.array=y.sig2.array,
                time.elapsed=tock-tick))
  }else{
    return(list(mean=y.pred, sig2=y.sig2-(y.pred)^2,
                time.elapsed=tock-tick))
  }
}
