% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.mcGP.R
\name{predict.mcGP}
\alias{predict.mcGP}
\title{Prediction for mesh-clustered Gaussian process emulator}
\usage{
\method{predict}{mcGP}(fit, Y, xnew = NULL, array.fg = FALSE)
}
\arguments{
\item{fit}{a class of \code{mcGP}.}

\item{Y}{same as \code{Y} for \code{\link[mcGP]{mcGP}}.}

\item{xnew}{an \code{n.new times d} matrix specifying the test input data. The default is \code{X} in \code{\link[mcGP]{mcGP}}.}

\item{array.fg}{logical. If \code{TRUE}, the prediction mean and variance for each cluster will be returned.}
}
\description{
Prediction for mesh-clustered Gaussian process emulator
}
\examples{
\dontrun{
library(mcGP)
set.seed(1)

##### setting #####
# example: Poisson equation simulations 
# (data was generated by finite element methods via MATLAB)
data(poisson_dat)
attach(poisson_dat)

print(dim(X)) # sample size is 5; one input variable
print(dim(S)) # 2-dimensional mesh; 401 mesh nodes
print(dim(Y)) # sample size is 5; 401 outputs at mesh nodes

# visualize two training examples
pde.plot <- function(u, nodes, ...){
  out <- as.image(u, x = nodes, nrow=128, ncol=128)
  dx <- out$x[2] - out$x[1] 
  dy <- out$y[2] - out$y[1] 
  out <- image.smooth(out$z, dx=dx, dy=dy, theta=.25) 
  image.plot(x = out$x, y = out$y, z = out$z, ...)
}

par(mfrow=c(1,2))
pde.plot(Y[,1], S, main=paste("x =", X[1,1]))
pde.plot(Y[,5], S, main=paste("x =", X[5,1]))

# model fitting
fit <- mcGP(X,Y,S)
print(fit$time.elapsed) # the time elapsed

# model fitting (with parallel computing)
fit <- mcGP(X,Y,S, parallel=TRUE)
print(fit$time.elapsed) # the time elapsed
}
}
\seealso{
\code{\link[mcGP]{mcGP}} for model fitting.
}
